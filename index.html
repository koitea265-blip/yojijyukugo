<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>四字熟語クイズ</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts (Klee One & BIZ UDPGothic) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic:wght@400;700&family=Klee+One:wght@400;600&display=swap" rel="stylesheet">
    
    <!-- Import Map for React modules -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
    }
    </script>
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* ベースフォント設定 */
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* HTMLレベルでスクロール禁止 */
        }
        body {
            /* フォント優先順位 */
            font-family: 'UD Digi Kyokasho N-R', 'UD Digi Kyokasho', 'Klee One', 'YuMincho', 'Hiragino Mincho ProN', 'Yu Mincho', 'MS PMincho', serif;
            background-color: #fffbeb; /* yellow-50 */
            /* 画面固定設定（モバイル対応） */
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100dvh; /* ダイナミックビューポート対応 */
            overscroll-behavior: none;
            touch-action: none;
            /* テキスト選択無効化（全体） */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #root {
            height: 100%;
            width: 100%;
            overflow: hidden;
            /* アプリ全体を中央寄せするためのフレックスコンテナ */
            display: flex;
            justify-content: center;
            background-color: #f7fee7;
        }
        
        /* 画像や要素のドラッグ禁止 */
        img, div, span, button {
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
        }

        /* ルビのスタイル調整 - Web標準に戻す */
        ruby {
            display: ruby; /* 標準のルビ表示 */
            ruby-position: over; /* ふりがなを上に */
            margin: 0 2px;
        }
        rt {
            font-size: 0.55em; /* 小さめに */
            color: #57534e; /* stone-600 */
            font-weight: normal;
            text-align: center;
            /* 行間を詰めて漢字に近づける */
            line-height: 1.0; 
        }
        
        /* タッチ操作の干渉を防ぐ */
        .card-touch-action-none {
            touch-action: none;
        }

        /* アニメーション定義 */
        @keyframes bounce-in {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); }
        }
        .animate-bounce-in {
            animation: bounce-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        /* スクロールバーのカスタマイズ（チラつき防止） */
        .no-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .no-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .no-scrollbar::-webkit-scrollbar-thumb {
            background-color: rgba(156, 163, 175, 0.5);
            border-radius: 20px;
        }
    </style>
</head>
<!-- コピー防止措置: 右クリック、コピー、カット、ペーストを無効化 -->
<body oncontextmenu="return false;" oncopy="return false;" oncut="return false;" onpaste="return false;">
    <div id="root"></div>

    <!-- アプリのソースコードをテキストとして保持 -->
    <script id="app-source" type="text/plain">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Sparkles, ArrowRight, RotateCcw, HelpCircle, GripVertical, Check, X, Circle, Star, Trophy, Trash2, Home, Lightbulb, Eye, Save } from 'lucide-react';

        // --- ユーティリティ: ルビ付きテキストのパース ---
        const parseMeaning = (text) => {
            const parts = text.split(/([一-龠々]+)\(([ぁ-んァ-ン]+)\)/g);
            return (
                <React.Fragment>
                {parts.map((part, i) => {
                    if (i % 3 === 1) { // 漢字
                    const rubyText = parts[i + 1]; // ふりがな
                    return (
                        <ruby key={i}>
                        {part}
                        <rt>{rubyText}</rt>
                        </ruby>
                    );
                    } else if (i % 3 === 2) { // ふりがな（処理済みなのでスキップ）
                    return null;
                    } else { // 通常テキスト
                    return part;
                    }
                })}
                </React.Fragment>
            );
        };

        // --- データセット (抜粋) ---
        const IDIOM_DATABASE = [
            { kanji: "一石二鳥", reading: "いっせきにちょう", charReadings: ["いっ","せき","に","ちょう"], meaning: "一(ひと)つの行為(こうい)で二(ふた)つの利益(りえき)を得(え)ること。" },
            { kanji: "一心同体", reading: "いっしんどうたい", charReadings: ["いっ","しん","どう","たい"], meaning: "二人(ふたり)以上(いじょう)の人(ひと)が、心(こころ)も体(からだ)も一(ひと)つであるかのように強(つよ)く結(むす)びつくこと。" },
            { kanji: "一生懸命", reading: "いっしょうけんめい", charReadings: ["いっ","しょう","けん","めい"], meaning: "命(いのち)がけで事(こと)に当(あ)たるように、本気(ほんき)で物事(ものごと)を行(おこな)うこと。" },
            { kanji: "起死回生", reading: "きしかいせい", charReadings: ["き","し","かい","せい"], meaning: "絶望的(ぜつぼうてき)な状態(じょうたい)から立(た)て直(なお)すこと。" },
            { kanji: "喜怒哀楽", reading: "きどあいらく", charReadings: ["き","ど","あい","らく"], meaning: "喜(よろこ)び、怒(いか)り、哀(かな)しみ、楽(たの)しみなどの人間(にんげん)の感情(かんじょう)。" },
            { kanji: "自画自賛", reading: "じがじさん", charReadings: ["じ","が","じ","さん"], meaning: "自分(じぶん)でしたことを、自分(じぶん)で褒(ほ)めること。" },
            { kanji: "四面楚歌", reading: "しめんそか", charReadings: ["し","めん","そ","か"], meaning: "周(まわ)りが敵(てき)や反対者(はんたいしゃ)ばかりで助(たす)けがないこと。" },
            { kanji: "弱肉強食", reading: "じゃくにくきょうしょく", charReadings: ["じゃく","にく","きょう","しょく"], meaning: "弱(よわ)い者(もの)が強(つよ)い者(もの)の犠牲(ぎせい)になること。" },
            { kanji: "十人十色", reading: "じゅうにんといろ", charReadings: ["じゅう","にん","と","いろ"], meaning: "人(ひと)それぞれ考(かんが)えや好(この)みが違(ちが)うこと。" },
            { kanji: "晴耕雨読", reading: "せいこううどく", charReadings: ["せい","こう","う","どく"], meaning: "晴(は)れた日(ひ)は畑(はたけ)を耕(たがや)し、雨(あめ)の日(ひ)は本(ほん)を読(よ)むような、自由(じゆう)な暮(く)らし。" },
            { kanji: "絶体絶命", reading: "ぜったいぜつめい", charReadings: ["ぜっ","たい","ぜつ","めい"], meaning: "どうにも逃(のが)れようのない危険(きけん)な立場(たちば)。" },
            { kanji: "大器晩成", reading: "たいきばんせい", charReadings: ["たい","き","ばん","せい"], meaning: "偉大(いだい)な人物(じんぶつ)は、世(よ)に出(で)るまでに時間(じかん)がかかること。" },
            { kanji: "電光石火", reading: "でんこうせっか", charReadings: ["でん","こう","せっ","か"], meaning: "動作(どうさ)などが非常(ひじょう)に素早(すばや)いことのたとえ。" },
            { kanji: "日進月歩", reading: "にっしんげっぽ", charReadings: ["にっ","しん","げっ","ぽ"], meaning: "絶(た)え間(ま)なくどんどん進歩(しんぽ)すること。" },
            { kanji: "馬耳東風", reading: "ばじとうふう", charReadings: ["ば","じ","とう","ふう"], meaning: "人(ひと)の意見(いけん)や批評(ひひょう)を聞(き)き流(なが)して、気(き)にしないこと。" },
            { kanji: "粉骨砕身", reading: "ふんこつさいしん", charReadings: ["ふん","こつ","さい","しん"], meaning: "骨(ほね)を粉(こ)にし身(み)を砕(くだ)くほど、全力(ぜんりょく)で努力(どりょく)すること。" },
            { kanji: "無我夢中", reading: "むがむちゅう", charReadings: ["む","が","む","ちゅう"], meaning: "我(われ)を忘(わす)れるほど、ある物事(ものごと)に熱中(ねっちゅう)すること。" },
            { kanji: "油断大敵", reading: "ゆだんたいてき", charReadings: ["ゆ","だん","たい","てき"], meaning: "気(き)を抜(ぬ)くと失敗(しっぱい)の原因(げんいん)になるので注意(ちゅうい)すること。" },
            { kanji: "臨機応変", reading: "りんきおうへん", charReadings: ["りん","き","おう","へん"], meaning: "その場(ば)の状況(じょうきょう)に応(おう)じて、適切(てきせつ)な処置(しょち)をとること。" },
            { kanji: "温故知新", reading: "おんこちしん", charReadings: ["おん","こ","ち","しん"], meaning: "昔(むかし)のことを学(まな)び、そこから新(あたら)しい知識(ちしき)や道理(どうり)を得(え)ること。" },
            { kanji: "五里霧中", reading: "ごりむちゅう", charReadings: ["ご","り","む","ちゅう"], meaning: "物事(ものごと)の様子(ようす)がわからず、方針(ほうしん)や見込(みこ)みが立(た)たないこと。" }
        ];

        const IDIOMS_PER_ROUND = 3;
        const STORAGE_KEY = 'yojijukugo_progress_v1';

        // 配列シャッフル関数
        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        function YojijukugoPuzzle() {
            const [gameState, setGameState] = useState('start'); // start, playing, result, end, all_clear
            const [currentIdioms, setCurrentIdioms] = useState([]);
            const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
            const [cards, setCards] = useState([]);
            const [slots, setSlots] = useState([]);
            const [completedRows, setCompletedRows] = useState({});
            const [solvedIdioms, setSolvedIdioms] = useState(() => {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    return saved ? JSON.parse(saved) : [];
                } catch (e) { return []; }
            });

            const [draggedCardId, setDraggedCardId] = useState(null);
            const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
            // 追加: ドラッグ中のカードのサイズを保持
            const [draggedCardDims, setDraggedCardDims] = useState({ width: 0, height: 0 });
            // 追加: 現在ドラッグ中のカードが重なっているドロップゾーンのID
            const [activeDropZoneId, setActiveDropZoneId] = useState(null);
            
            const containerRef = useRef(null);
            const audioCtxRef = useRef(null);

            // 保存ロジック
            useEffect(() => {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(solvedIdioms));
            }, [solvedIdioms]);

            // 音声再生
            const playSoundEffect = useCallback((type) => {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) return;
                    
                    if (!audioCtxRef.current) {
                        audioCtxRef.current = new AudioContext();
                    }
                    const ctx = audioCtxRef.current;
                    
                    // ユーザー操作時などにresumeが必要
                    if (ctx.state === 'suspended') {
                        ctx.resume().catch(() => {});
                    }

                    const t = ctx.currentTime;

                    if (type === 'correct') {
                        // 「ピンポン！」音を作成 (ソ -> ド)
                        
                        // 1音目 (ソ: G5 approx 784Hz)
                        const osc1 = ctx.createOscillator();
                        const gain1 = ctx.createGain();
                        osc1.type = 'sine'; // 柔らかい音
                        osc1.frequency.setValueAtTime(784, t);
                        osc1.connect(gain1);
                        gain1.connect(ctx.destination);
                        
                        gain1.gain.setValueAtTime(0, t);
                        gain1.gain.linearRampToValueAtTime(0.1, t + 0.05); // アタック
                        gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.4); // リリース
                        
                        osc1.start(t);
                        osc1.stop(t + 0.4);

                        // 2音目 (ド: C6 approx 1047Hz) - 0.15秒後に再生
                        const osc2 = ctx.createOscillator();
                        const gain2 = ctx.createGain();
                        osc2.type = 'sine';
                        osc2.frequency.setValueAtTime(1047, t + 0.15);
                        osc2.connect(gain2);
                        gain2.connect(ctx.destination);
                        
                        gain2.gain.setValueAtTime(0, t + 0.15);
                        gain2.gain.linearRampToValueAtTime(0.1, t + 0.2);
                        gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.8); // 余韻長め
                        
                        osc2.start(t + 0.15);
                        osc2.stop(t + 0.8);

                    } else if (type === 'completion') {
                        osc.type = 'sine';
                        [523.25, 659.25, 783.99, 1046.50, 1318.51].forEach((freq, i) => {
                            const osc2 = ctx.createOscillator();
                            const gain2 = ctx.createGain();
                            osc2.connect(gain2);
                            gain2.connect(ctx.destination);
                            osc2.type = 'triangle';
                            osc2.frequency.value = freq;
                            gain2.gain.setValueAtTime(0.05, ctx.currentTime + i * 0.1);
                            gain2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.1 + 0.5);
                            osc2.start(ctx.currentTime + i * 0.1);
                            osc2.stop(ctx.currentTime + i * 0.1 + 0.5);
                        });
                    }
                } catch (e) { console.error("Audio failed", e); }
            }, []);

            // ゲーム開始
            const startRandomRound = () => {
                // スタート時にオーディオコンテキストを確実に再開
                if (audioCtxRef.current && audioCtxRef.current.state === 'suspended') {
                    audioCtxRef.current.resume().catch(() => {});
                } else if (!audioCtxRef.current) {
                    // まだ作成されていない場合は作成を試みる
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        if (AudioContext) {
                            audioCtxRef.current = new AudioContext();
                        }
                    } catch(e) {}
                }

                const unsolvedList = IDIOM_DATABASE.filter(item => !solvedIdioms.includes(item.kanji));
                if (unsolvedList.length === 0) {
                    setGameState('all_clear');
                    return;
                }
                const roundData = shuffleArray(unsolvedList).slice(0, IDIOMS_PER_ROUND);
                setCurrentIdioms(roundData);

                const newSlots = [];
                const newCards = [];
                roundData.forEach((idiom, iIdx) => {
                    idiom.kanji.split('').forEach((char, cIdx) => {
                        const slotId = `slot-${iIdx}-${cIdx}`;
                        newSlots.push({ id: slotId, idiomIndex: iIdx, charIndex: cIdx, correctChar: char });
                        newCards.push({
                            id: `card-${iIdx}-${cIdx}`,
                            char: char,
                            charReading: idiom.charReadings ? idiom.charReadings[cIdx] : "",
                            currentSlotId: null,
                            isDragging: false
                        });
                    });
                });
                setSlots(newSlots);
                setCards(shuffleArray(newCards));
                setCompletedRows({});
                setGameState('playing');
            };

            // 操作イベント
            const handlePointerDown = (e, cardId) => {
                const card = cards.find(c => c.id === cardId);
                // 完了した列のカードは動かせない
                if (card && card.currentSlotId) {
                    const slot = slots.find(s => s.id === card.currentSlotId);
                    if (slot && completedRows[slot.idiomIndex]) return;
                }
                
                // カードのサイズを取得
                const rect = e.currentTarget.getBoundingClientRect();
                setDraggedCardDims({ width: rect.width, height: rect.height });

                setDraggedCardId(cardId);
                setDragPosition({ x: e.clientX, y: e.clientY });
                setCards(prev => prev.map(c => c.id === cardId ? { ...c, isDragging: true } : c));
            };

            // 交差判定ヘルパー関数
            const getIntersectingDropZone = (pointerX, pointerY, cardDims) => {
                const dropZones = document.querySelectorAll('.drop-zone');
                let bestZone = null;
                let maxOverlapArea = 0;

                // ドラッグ中のカードの推測矩形 (translate -50%, -120%)
                const cardW = cardDims.width;
                const cardH = cardDims.height;
                const cardLeft = pointerX - (cardW / 2);
                const cardTop = pointerY - (cardH * 1.2);
                const cardRight = cardLeft + cardW;
                const cardBottom = cardTop + cardH;

                dropZones.forEach(zone => {
                    const rect = zone.getBoundingClientRect();
                    
                    // 矩形の交差判定
                    const intersectLeft = Math.max(cardLeft, rect.left);
                    const intersectTop = Math.max(cardTop, rect.top);
                    const intersectRight = Math.min(cardRight, rect.right);
                    const intersectBottom = Math.min(cardBottom, rect.bottom);

                    if (intersectLeft < intersectRight && intersectTop < intersectBottom) {
                        // 重なっている場合、その面積を計算
                        const area = (intersectRight - intersectLeft) * (intersectBottom - intersectTop);
                        if (area > maxOverlapArea) {
                            maxOverlapArea = area;
                            bestZone = zone;
                        }
                    }
                });
                return bestZone;
            };

            const handlePointerMove = (e) => {
                if (!draggedCardId) return;
                e.preventDefault();
                setDragPosition({ x: e.clientX, y: e.clientY });

                // ドロップゾーンの検知とハイライト (矩形衝突判定)
                const dropZone = getIntersectingDropZone(e.clientX, e.clientY, draggedCardDims);
                
                if (dropZone) {
                    setActiveDropZoneId(dropZone.dataset.slotId);
                } else {
                    setActiveDropZoneId(null);
                }
            };

            const handlePointerUp = (e) => {
                if (!draggedCardId) return;
                
                // ドロップ判定 (矩形衝突判定)
                const dropZone = getIntersectingDropZone(e.clientX, e.clientY, draggedCardDims);

                setCards(prev => {
                    const newCards = [...prev];
                    const idx = newCards.findIndex(c => c.id === draggedCardId);
                    if (dropZone) {
                        const targetSlotId = dropZone.dataset.slotId;
                        const targetSlot = slots.find(s => s.id === targetSlotId);
                        const isCorrect = targetSlot && targetSlot.correctChar === newCards[idx].char;
                        const isOccupied = newCards.some(c => c.currentSlotId === targetSlotId && c.id !== draggedCardId);
                        
                        // 正解かつ空いている場合のみ配置
                        if (isCorrect && !isOccupied) {
                            newCards[idx].currentSlotId = targetSlotId;
                        } else {
                            newCards[idx].currentSlotId = null;
                        }
                    } else {
                        newCards[idx].currentSlotId = null;
                    }
                    newCards[idx].isDragging = false;
                    return newCards;
                });
                setDraggedCardId(null);
                setActiveDropZoneId(null); // ハイライトのリセット
            };

            // 追加: ドラッグキャンセル時の処理 (画面外に出た場合など)
            const handlePointerCancel = () => {
                if (!draggedCardId) return;
                setCards(prev => prev.map(c => c.id === draggedCardId ? { ...c, isDragging: false } : c));
                setDraggedCardId(null);
                setActiveDropZoneId(null);
            };

            // 判定ロジック
            useEffect(() => {
                if (gameState !== 'playing') return;
                const newCompletedRows = { ...completedRows };
                let soundTriggered = false;
                let newlySolved = [];

                currentIdioms.forEach((idiom, iIdx) => {
                    if (completedRows[iIdx]) return;
                    const rowSlotIds = slots.filter(s => s.idiomIndex === iIdx).map(s => s.id);
                    const isRowComplete = rowSlotIds.every(sid => cards.some(c => c.currentSlotId === sid));
                    if (isRowComplete) {
                        newCompletedRows[iIdx] = true;
                        soundTriggered = true;
                        newlySolved.push(idiom.kanji);
                    }
                });

                if (soundTriggered) {
                    setCompletedRows(newCompletedRows);
                    playSoundEffect('correct');
                    setSolvedIdioms(prev => {
                        const next = [...prev];
                        newlySolved.forEach(k => { if (!next.includes(k)) next.push(k); });
                        return next;
                    });
                }
            }, [cards]);

            // 全問正解チェック
            const isAllComplete = currentIdioms.length > 0 && Object.keys(completedRows).length === currentIdioms.length;

            const handleRoundComplete = () => {
                playSoundEffect('completion');
                if (solvedIdioms.length >= IDIOM_DATABASE.length) setGameState('all_clear');
                else startRandomRound();
            };

            const handleHint = (idiomIndex) => {
                setCards(prev => {
                    const next = [...prev];
                    const targetSlotId = `slot-${idiomIndex}-0`;
                    const targetCard = next.find(c => c.id === `card-${idiomIndex}-0`);
                    if(targetCard) {
                        // 既にその場所にいるカードを追い出す
                        const occupier = next.find(c => c.currentSlotId === targetSlotId && c.id !== targetCard.id);
                        if(occupier) occupier.currentSlotId = null;
                        targetCard.currentSlotId = targetSlotId;
                    }
                    return next;
                });
            };

            const handleShowAnswer = (idiomIndex) => {
                setCards(prev => {
                    const next = [...prev];
                    [0,1,2,3].forEach(cIdx => {
                        const targetSlotId = `slot-${idiomIndex}-${cIdx}`;
                        const targetCard = next.find(c => c.id === `card-${idiomIndex}-${cIdx}`);
                        if(targetCard) {
                             const occupier = next.find(c => c.currentSlotId === targetSlotId && c.id !== targetCard.id);
                             if(occupier) occupier.currentSlotId = null;
                             targetCard.currentSlotId = targetSlotId;
                        }
                    });
                    return next;
                });
            };

            // Global Pointer Events
            useEffect(() => {
                if (draggedCardId) {
                    window.addEventListener('pointermove', handlePointerMove, { passive: false });
                    window.addEventListener('pointerup', handlePointerUp);
                    window.addEventListener('pointercancel', handlePointerCancel);
                }
                return () => {
                    window.removeEventListener('pointermove', handlePointerMove);
                    window.removeEventListener('pointerup', handlePointerUp);
                    window.removeEventListener('pointercancel', handlePointerCancel);
                };
            }, [draggedCardId]);


            // --- レンダリング ---
            const renderCard = (card) => {
                if (!card) return null;
                // スマホタッチ時の視認性向上: 指の少し上に表示 (-100% オフセット)
                const style = card.isDragging ? {
                    position: 'fixed', left: dragPosition.x, top: dragPosition.y,
                    transform: 'translate(-50%, -120%)', zIndex: 9999, pointerEvents: 'none'
                } : { position: 'relative', width: '100%', height: '100%' };
                
                return (
                    <div
                        key={card.id}
                        onPointerDown={(e) => handlePointerDown(e, card.id)}
                        className={`
                            card-touch-action-none
                            flex flex-col justify-center items-center gap-0 md:gap-1 rounded-xl select-none cursor-grab active:cursor-grabbing transition-transform duration-200 font-bold bg-white border-2 border-stone-800 
                            ${card.isDragging ? 'shadow-xl opacity-90 scale-110 w-20 h-20 md:w-24 md:h-24' : 'w-full h-full hover:-translate-y-1 shadow-md'}
                        `}
                        style={style}
                    >
                        {/* スマホ時のみマイナスマージンで近づける -mb-1に変更 */}
                        <div className="text-[10px] md:text-xs text-stone-500 -mb-1 md:mb-0 leading-none">{card.charReading}</div>
                        <div className="text-4xl md:text-6xl leading-none">{card.char}</div>
                    </div>
                );
            };

            // スタート画面
            if (gameState === 'start') {
                const progressPercent = Math.round((solvedIdioms.length / IDIOM_DATABASE.length) * 100);
                
                return (
                    <div className="h-full w-full flex items-center justify-center p-2 select-none overflow-hidden max-w-6xl mx-auto shadow-2xl bg-yellow-50">
                        <div className="bg-white w-full max-w-md rounded-3xl shadow-xl overflow-hidden border-4 border-orange-200 flex flex-col h-full max-h-[90vh]">
                            {/* ヘッダーエリア */}
                            <div className="bg-orange-400 p-4 text-center relative overflow-hidden shrink-0">
                                <div className="absolute top-0 left-0 w-full h-full opacity-20">
                                    {[...Array(10)].map((_, i) => (
                                        <Star key={i} className="absolute text-white" style={{
                                        top: `${Math.random()*100}%`, left: `${Math.random()*100}%`, 
                                        transform: `scale(${0.5 + Math.random()})`
                                        }} />
                                    ))}
                                </div>
                                <h1 className="text-2xl md:text-3xl font-bold text-white tracking-widest mb-1 drop-shadow-md relative z-10 whitespace-nowrap">四字熟語クイズ</h1>
                                <div className="inline-block bg-white text-orange-500 font-bold text-xs md:text-sm px-3 py-0.5 rounded-full relative z-10 shadow-sm">
                                    全{IDIOM_DATABASE.length}問
                                </div>
                            </div>
                            
                            {/* スクロール可能エリア */}
                            <div className="p-4 bg-white overflow-y-auto flex-1 flex flex-col">
                                {/* 進捗表示エリア */}
                                <div className="mb-4 bg-orange-50 p-3 rounded-xl border-2 border-orange-100 text-center shrink-0">
                                    <div className="text-stone-500 font-bold mb-0.5 text-xs">現在のクリア数</div>
                                    <div className="flex items-end justify-center gap-1 text-orange-600">
                                        <span className="text-2xl md:text-3xl font-bold">{solvedIdioms.length}</span>
                                        <span className="text-sm md:text-lg font-bold pb-1 text-orange-400">/ {IDIOM_DATABASE.length}</span>
                                    </div>
                                    <div className="w-full bg-orange-200 rounded-full h-2 mt-1">
                                        <div className="bg-orange-500 h-2 rounded-full transition-all duration-1000" style={{ width: `${progressPercent}%` }}></div>
                                    </div>
                                </div>

                                <h2 className="font-bold text-lg mb-2 flex items-center gap-2 text-orange-600 shrink-0">
                                    <HelpCircle className="w-5 h-5"/> あそびかた
                                </h2>
                                <div className="space-y-2 text-stone-600 text-sm md:text-base shrink-0">
                                    <div className="flex gap-2 items-start">
                                        <div className="w-6 h-6 rounded-full bg-orange-100 text-orange-600 flex items-center justify-center font-bold shrink-0 text-xs">1</div>
                                        <p className="pt-0.5">左の「漢字カード」を指でつかんでね。</p>
                                    </div>
                                    <div className="flex gap-2 items-start">
                                        <div className="w-6 h-6 rounded-full bg-orange-100 text-orange-600 flex items-center justify-center font-bold shrink-0 text-xs">2</div>
                                        <p className="pt-0.5">意味をヒントにして、右の四角にいれてね。</p>
                                    </div>
                                    <div className="flex gap-2 items-start">
                                        <div className="w-6 h-6 rounded-full bg-orange-100 text-orange-600 flex items-center justify-center font-bold shrink-0 text-xs">3</div>
                                        <div className="pt-0.5">
                                            <p>わからないときはボタンを使おう！</p>
                                            <div className="flex flex-wrap gap-2 mt-1">
                                                <div className="flex items-center gap-1">
                                                    <span className="bg-yellow-400 text-white p-0.5 px-1 rounded shadow-sm"><Lightbulb className="w-3 h-3" /></span>
                                                    <span className="text-xs">ヒント</span>
                                                </div>
                                                <div className="flex items-center gap-1">
                                                    <span className="bg-sky-400 text-white p-0.5 px-1 rounded shadow-sm"><Eye className="w-3 h-3" /></span>
                                                    <span className="text-xs">こたえ</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* フッターエリア */}
                            <div className="p-4 bg-white border-t border-stone-100 shrink-0">
                                <button 
                                    onClick={startRandomRound}
                                    className="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold text-lg md:text-xl py-3 rounded-xl shadow-lg border-b-4 border-orange-700 active:border-b-0 active:translate-y-1 transition-all flex items-center justify-center gap-2"
                                >
                                    <Sparkles className="w-5 h-5 md:w-6 md:h-6" /> 
                                    {solvedIdioms.length > 0 ? "つづきから" : "スタート！"}
                                </button>
                                {solvedIdioms.length > 0 && (
                                    <button onClick={() => { if(confirm('本当にリセットしますか？')) { localStorage.removeItem(STORAGE_KEY); setSolvedIdioms([]); } }} className="mt-2 w-full text-stone-400 text-xs hover:text-red-500 flex items-center justify-center gap-1">
                                        <Trash2 className="w-3 h-3"/> きろくを消す
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameState === 'all_clear') {
                return (
                    <div className="h-full w-full flex items-center justify-center p-4 max-w-6xl mx-auto shadow-2xl bg-yellow-50">
                        <div className="bg-white max-w-md w-full rounded-3xl shadow-xl border-4 border-orange-200 p-8 text-center animate-bounce-in">
                            <Trophy className="w-20 h-20 text-yellow-500 mx-auto mb-4" />
                            <h2 className="text-3xl font-bold text-orange-600 mb-4">全問クリア！</h2>
                            <p className="text-stone-600 font-bold mb-8">おめでとう！<br/>きみは四字熟語マスターだ！</p>
                            <button onClick={() => setGameState('start')} className="bg-sky-400 text-white font-bold py-3 px-8 rounded-full shadow-md">トップへ戻る</button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full w-full flex flex-col bg-yellow-50 overflow-hidden max-w-6xl mx-auto shadow-2xl" ref={containerRef}>
                    {/* 共通ヘッダー (PC/SP両方で最上部に表示) */}
                    <header className="bg-white shadow-sm px-4 py-2 flex justify-between items-center border-b-2 border-orange-100 z-30 shrink-0">
                        <button onClick={() => setGameState('start')} className="text-orange-600 flex items-center gap-1 text-sm font-bold bg-orange-100 px-3 py-1 rounded-full"><Home size={16}/> トップ</button>
                        <div className="text-orange-800 font-bold text-sm">のこり <span className="text-xl text-orange-500">{IDIOM_DATABASE.length - solvedIdioms.length}</span> 問</div>
                        <div className="w-20 flex justify-end">
                            {isAllComplete && (
                                <button onClick={handleRoundComplete} className="bg-green-500 text-white text-sm font-bold py-1 px-3 rounded-full shadow-md flex items-center gap-1 animate-bounce">
                                    次へ <ArrowRight size={16}/>
                                </button>
                            )}
                        </div>
                    </header>

                    {/* コンテンツエリア (flex-row: PCでは横並び, SPでは独自レイアウト) */}
                    <div className="flex-1 flex flex-col md:flex-row overflow-hidden items-start pt-2 px-2 pb-2 gap-2">
                        
                        {/* 左：漢字カードエリア (PC: order-1, SP: order-2) */}
                        <div className="md:w-1/3 flex flex-col order-2 md:order-1 z-20 w-full h-[30%] md:h-auto md:max-h-full">
                            <div className="border-4 border-orange-300 rounded-2xl overflow-hidden flex flex-col bg-orange-100 relative shadow-sm h-full md:h-auto md:max-h-full">
                                <div className="p-2 bg-orange-200 text-orange-800 font-bold flex justify-between items-center shrink-0">
                                    <span className="flex items-center gap-2"><Star className="fill-orange-500 text-orange-500" size={18}/> 漢字カード</span>
                                    <span className="text-xs bg-white px-2 py-0.5 rounded-full text-orange-600">あと {cards.filter(c => !c.currentSlotId).length} 枚</span>
                                </div>
                                <div className="flex-1 p-2 overflow-y-auto">
                                    <div className="flex flex-wrap justify-center gap-2">
                                        {cards.map(card => {
                                            const isPlaced = card.currentSlotId !== null;
                                            return (
                                                <div key={card.id} className={`${isPlaced ? 'invisible' : ''} w-16 h-16 md:w-24 md:h-24`}>
                                                    {renderCard(card)}
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* 右：問題エリア (PC: order-2, SP: order-1) */}
                        <div className="flex-1 flex flex-col order-1 md:order-2 w-full h-[70%] md:h-auto md:max-h-full items-start overflow-hidden">
                            <div className="border-4 border-orange-300 rounded-2xl overflow-hidden flex flex-col bg-white/30 relative w-fit max-w-full max-h-full">
                                <div className="bg-orange-200 text-orange-800 text-center py-1 text-xs font-bold shrink-0">
                                    漢字カードをドラッグして、四字熟語を完成させよう
                                </div>
                                <div className="overflow-y-auto p-2 md:p-4 space-y-4">
                                    {currentIdioms.map((idiom, iIdx) => (
                                        <div key={iIdx} className="bg-white p-2 rounded-xl shadow-sm border border-orange-200 w-fit max-w-full">
                                            <div className="mb-2 text-sm md:text-base bg-amber-100 text-black font-bold px-3 py-2 rounded-lg border-l-4 border-amber-400 flex items-start gap-2">
                                                <span className="shrink-0">意味:</span>
                                                <span className="leading-loose">{parseMeaning(idiom.meaning)}</span>
                                            </div>
                                            
                                            <div className="flex gap-2 items-center justify-start">
                                                <div className="flex gap-1 md:gap-2">
                                                    {[0,1,2,3].map(cIdx => {
                                                        const slotId = `slot-${iIdx}-${cIdx}`;
                                                        const card = cards.find(c => c.currentSlotId === slotId);
                                                        // アクティブなドロップゾーンかどうか判定
                                                        const isHovered = activeDropZoneId === slotId;
                                                        
                                                        return (
                                                            <div 
                                                                key={slotId} 
                                                                data-slot-id={slotId} 
                                                                className={`
                                                                    drop-zone w-16 h-16 md:w-24 md:h-24 rounded-xl flex items-center justify-center transition-all duration-200
                                                                    ${card ? '' : 'bg-stone-100 border-2 border-dashed border-stone-300'}
                                                                    ${isHovered ? 'bg-yellow-100 border-yellow-400 border-4 scale-110 shadow-lg' : ''}
                                                                `}
                                                            >
                                                                {!card && <div className={`w-2 h-2 rounded-full ${isHovered ? 'bg-yellow-400' : 'bg-stone-300'}`}></div>}
                                                                {card && renderCard(card)}
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                                
                                                <div className="w-12 flex flex-col gap-1">
                                                    {completedRows[iIdx] ? (
                                                        <div className="text-rose-500 animate-bounce-in"><Circle size={40} strokeWidth={3}/></div>
                                                    ) : (
                                                        <>
                                                            <button onClick={() => handleHint(iIdx)} className="bg-yellow-400 text-white p-1 rounded-lg shadow-sm flex justify-center"><Lightbulb size={16}/></button>
                                                            <button onClick={() => handleShowAnswer(iIdx)} className="bg-sky-400 text-white p-1 rounded-lg shadow-sm flex justify-center"><Eye size={16}/></button>
                                                        </>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* ドラッグ中のカード描画レイヤー */}
                    {cards.filter(c => c.isDragging).map(card => renderCard(card))}
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<YojijukugoPuzzle />);
    </script>

    <!-- 手動トランスパイル実行用スクリプト -->
    <script type="module">
        const jsx = document.getElementById('app-source').innerHTML;
        try {
            const transformed = Babel.transform(jsx, { presets: ['react'] }).code;
            const script = document.createElement('script');
            script.type = 'module';
            script.text = transformed;
            document.body.appendChild(script);
        } catch (e) {
            console.error("Transpile Failed:", e);
        }
    </script>
</body>
</html>
